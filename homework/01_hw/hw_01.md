---
title: Homework 1
subtitle: Color spaces, annotations, thresholding, filters, and wavelets
downloads:
  - file: hw_01.ipynb
    title: hw_01.ipynb
kernelspec:
  name: python3
  display_name: "Python 3"
---

## Assignment

This problem set deals with material from the first four lectures. 

:::{note}
- You may reference any materials, but make sure if you directly copy code, that you provide a link to the source in the mark up. Likewise, if you find a really helpful website, you should add that link as well.

- Include any additional scripts or files needed to reproduce.
:::

## Import modules
:::{code-cell} python
import os
import cv2
import numpy as np
from matplotlib import pyplot as plt
import ipywidgets as widgets
import homework as hw # see homework.py file
import pywt
:::

## Problem 1
Load the `Pitt_Cathedral.jpg` file from the `Data` folder as a color image, convert the image colors and disply using the `imshow()` command, and convert to grayscale and display the image again.

:::{code} python
# read in the image
img = cv2.imread(os.path.relpath('Data/Pitt_Cathedral.jpg'), cv2.IMREAD_COLOR)

# convert to RGB
img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

# convert to grayscale
img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# show the results
fig, axs = plt.subplots(2, 2, figsize=(8,6), layout='constrained')
fig.suptitle('Problem 1 Solution')
axs[0,0].imshow(img); axs[0,0].set_title('BGR')
axs[0,1].imshow(img_rgb); axs[0,1].set_title('RGB')
axs[1,0].imshow(img_gray, cmap='gray', vmin=0, vmax=255); axs[1,0].set_title('Grayscale')
axs[1,1].axis('off')
plt.show()
:::

:::{figure} Data/p1_sol.jpg
:align: center
:::

## Problem 2
1. Annotate the Cathedral image from [Problem 1](#problem-1) with the slogan "Hail to Pitt" placed in the image.
2. In a different font and color, add your name in text to the same image.
3. Crop the image around the Cathedral and display the image.

:::{code} python
# create a copy of the image
img_annotated = img_rgb.copy()

# H2P text
h2p = {
    'text': 'Hail to Pitt',
    'scale': 2.3,
    'face': cv2.FONT_HERSHEY_SIMPLEX,
    'color': (0, 0, 255), # blue
    'thickness': 2,
    'origin': (325, 75),
    'lineType': cv2.LINE_AA
}

# annotate the image
cv2.putText(
    img_annotated, 
    h2p['text'],
    h2p['origin'],
    h2p['face'],
    h2p['scale'],
    h2p['color'],
    h2p['thickness'],
    h2p['lineType']
)

# Name text
name = {
    'text': 'Jacob Cunningham',
    'scale': h2p['scale'],
    'face': cv2.FONT_HERSHEY_PLAIN,
    'color': (255, 0, 0), # red
    'thickness': h2p['thickness'],
    'origin': (350, 675),
    'lineType': h2p['lineType']
}

# annotate the image
cv2.putText(
    img_annotated, 
    name['text'],
    name['origin'],
    name['face'],
    name['scale'],
    name['color'],
    name['thickness'],
    name['lineType']
)

# crop the image
img_cropped = img_annotated.copy()[0:701, 250:801]

# show the image
fig, axd = plt.subplot_mosaic([['Original', 'Cropped'], ['Annotated', 'Cropped']], figsize=(6, 4), layout='constrained')
fig.suptitle('Problem 2 Solution')
axd['Original'].imshow(img_rgb); axd['Original'].set_title('Original')
axd['Annotated'].imshow(img_annotated); axd['Annotated'].set_title('Annotated')
axd['Cropped'].imshow(img_cropped); axd['Cropped'].set_title('Cropped')
plt.show()
:::

:::{figure} Data/p2_sol.jpg
:align: center
:::

## Problem 3
1. Create a binary mask separating the blue sky by thresholding
2. Using this mask, change (just the) sky to be a deeper blue

### Preprocessing

__Get image information__

:::{code} python
# get the image size
height, width = img.shape[:2]

# convert to hsv
img_hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)

# split the color channels
r, g, b = cv2.split(img_rgb)
h, s, v = cv2.split(img_hsv)

# plot the images and their histograms
fig, axs = plt.subplots(3, 2, figsize=(8,8), layout='constrained')
axs[0,0].imshow(img_rgb)
axs[0,0].set_title('RGB')
axs[0,1].hist(r.ravel(), bins=75, color='red', alpha=0.5, label='Red')
axs[0,1].hist(b.ravel(), bins=75, color='blue', alpha=0.5, label='Blue')
axs[0,1].hist(g.ravel(), bins=75, color='green', alpha=0.5, label='Green')
axs[0,1].legend()
axs[0,1].set_title('Image Histogram')
axs[1,0].imshow(img_rgb)
axs[1,0].set_title('HSV') # since RGB required for matplotlib
axs[1,1].hist(h.ravel(), bins=75, color='red', alpha=0.5, label='Hue')
axs[1,1].hist(s.ravel(), bins=75, color='blue', alpha=0.5, label='Saturation')
axs[1,1].hist(v.ravel(), bins=75, color='green', alpha=0.5, label='Value')
axs[1,1].legend()
axs[1,1].set_title('Image Histogram')
axs[2,0].imshow(img_gray, cmap='gray', vmin=0, vmax=255)
axs[2,0].set_title('Grayscale')
axs[2,1].hist(img_gray.ravel(), bins=75, color='gray', edgecolor='black')
axs[2,1].set_title('Image Histogram')
fig.suptitle(f'Pitt Cathedral: {width} pixels by {height} pixels')
plt.show()
:::

:::{figure} Data/p2_info.jpg
:align: center
:::

:::{note}
The grayscale image is bimodal which indicates segmentation by thresholding may be a good approach.
:::

__Various threshold techniques__

:::{code} python
# global method
val_global, img_global = cv2.threshold(img_gray, 100, 255, cv2.THRESH_BINARY)

# Otsus method
val_otsus, img_otsus = cv2.threshold(img_gray, 167, 255, cv2.THRESH_OTSU)

# adaptive thresholds
img_adpt_mean = cv2.adaptiveThreshold(img_gray, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 9, 0)
img_adpt_gauss = cv2.adaptiveThreshold(img_gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 9, 0)

# show the results
fig, axs = plt.subplots(2, 2, figsize=(8,6), layout='constrained')
fig.suptitle('Threshold Methods and Results')
axs[0,0].imshow(img_global, cmap='gray', vmin=0, vmax=255); axs[0,0].set_title(f'Global Threshold of {val_global:.0f}')
axs[0,1].imshow(img_otsus, cmap='gray', vmin=0, vmax=255); axs[0,1].set_title(f'Otsus Threshold of {val_otsus:.0f}')
axs[1,0].imshow(img_adpt_mean, cmap='gray', vmin=0, vmax=255); axs[1,0].set_title('Adaptive Mean')
axs[1,1].imshow(img_adpt_gauss, cmap='gray', vmin=0, vmax=255); axs[1,1].set_title('Adaptive Gaussian')
plt.show()
:::

:::{figure} Data/p2_thresh_techs.jpg
:align: center
:::

:::{code-cell} python
# script used to finetune threshold value
hw.finetune_threshold(img_rgb)
:::

After finetuning, select a threshold value.

